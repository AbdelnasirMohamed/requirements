\section{Formal approaches for the design and development of a system}


Very roughly, from an engineering point of view three kinds of formal
methods can be used for the design and development of a system:
\begin{itemize}
\item Contract based approaches;
\item Model checking of concurrent and synchronous languages;
\item Static analysis of software code.
\end{itemize}

\subsection{Contract based approach}
\label{sec:contr-based-appr}

Contract based approaches are based on software (or model)
annotation. The software is usually considered state based, i.e. made of
a state stored in a set of typed variables.  Software is divided in a
set of operations (aka procedures, functions, methods, \ldots). To each
operation a pre-condition is associated, i.e., a set of conditions that
should be guaranteed at operation entrance by the caller of the
operation. To each operation there is also a post-condition associated
that the operation should fulfill, provided the pre-condition is
assumed. In other words, the called operation should ensure the
post-condition. The pre and post-conditions are usually expressed using
first order logic (and, or, implication, for all and exists quantifiers,
\ldots).

In the contract based approach, if all the pre and post-conditions are
fulfilled for all possible executions, then we can guarantee that all
the operations work well together.

Those kind of approaches are known to be scalable, at the price of
sometimes a lot of manual work to properly annotate the software or
prove the annotations are correct.

Examples of such approaches are B~Method, Event-B, GNATprove/SPARK on
Ada language or Frama-C on C language.

\subsection{Model checking of concurrent and synchronous languages}

In this approach, models are based on various textual or graphical
formalisms: state based model (like State Machines), data flow equations
or Petri Nets.

In a second step, a property is formalized over this model, usually
using temporal logic. A temporal logic is usually a first order logic
augmented with operators expressing the relationship between events:
in the next event, a property is true until another property is true,
etc.

Then, model checking techniques (symbolic model checking, exhaustive
state enumeration, ...) are applied to check that the expressed
property is valid over the model, for all possible executions.

Compared to previous contract based approach, model checking allows to
verify more complex properties along the life time of the system. For
example, one can express that ``something good'' will occur in the
future after a certain event.

On the other hand, model checking requires a finite state space. In
general systems represent an infinite state space and therefore a finite
abstraction must be derived for model checking. However model checking
suffers from state explosion problem: if the model is not properly
designed, it can have too many states and make the exhaustive
verification impossible. To limit this problem  , model-checking approaches are often links with abstraction and decomposition techniques.

Example of such approaches and tools are Design Verifier (used in
SCADE), Petri Nets, NuSMV, UPPAAL or SPIN.

\subsection{Static analysis of software code}

Static analysis techniques are inspired by abstract interpretation
techniques proposed by Cousot and Cousot in 1977. The main idea is to
transform the domain of concrete program variables into a simpler,
abstract domain. Then the analysis is done, for all possible execution
paths, within this abstract domain. And finally the result of the
analysis is put back on the original concrete variables.

Constructing an abstract interpretation is done using specific
mathematical approaches (mainly Galois connections) that ensure that
the result of the analysis is sound: if an issue is found by the
analysis in the abstract domain, it exists in the concrete domains of
the variables, i.e., in the real program.

On the contrary, completeness of the approach (ie. ensuring that any issue of the concrete domains are covered by an issue of the abstract domain) is difficult to ensure:
due to abstraction, the analysis can make some approximation. In such
cases the result of the analysis is meaningless: the analysis cannot
tell if a verified property is valid or not.

The main advantage of static analysis is that it works on actual,
concrete software code, with minimal annotations. It thus integrates
quite easily with existing development process, along testing phase
for example. And it is highly automated, requesting minimal user
intervention.

The drawback of this approach is that it is restricted to certain kind
of properties (overflow, underflow, out-of-bound accesses, division by
zero). Moreover it does not apply well to all kind of programs.


Example of tool applying such approach are Polyspace, Astr√©e or
Frama-C (with Value analysis plug-in).


%% \subsection{What means are involved behind a formal approach ?}

%% \subsubsection{Model edition}

%% \subsubsection{Mathematical analyses}
%% static checking, proof, model-checking, ...

%% \subsubsection{Simulation and code generation}



%% \begin{comment}
%% This section will describe how formal methods are involved in the design of critical system.
%% \end{comment}



%% \subsection{System level model}

%% \subsection{Software level model}

%% \subsection{Functional architecture}

%% \subsection{Safety properties expression}

%% \req{The model-level safety properties shall be written in a formal language.}




