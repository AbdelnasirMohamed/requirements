
\section{Guidelines on the approaches used for OpenETCS}

\subsection{Definition of an OpenETCS methodology}



\req{The model formalism shall be easily understandable by the domain experts.}
\req{The safety properties should be provided in a declarative, simple and formal language.}
\req{The formal model shall be understandable by or exportable to many tools
(SCADE, Simulink, B tools, OpenETCS tool chain\dots)}



\req{Formal specifications should be able to formalize:}
\subreq{State machines,}
\subreq{Time-outs,}
\subreq{Truth tables,}
\subreq{Arithmetics,}
\subreq{Braking curves,}
\subreq{Logical statements.}

\begin{comment}
This requirement does not state that all these objects need to be \emph{first order objects} of
the language. It only state that it should be possible (easy?) to formalize and manipulate them.

It is to be noted that if (for example) braking curves are objects of the language, it shall be
proved that they are sound, and that the code generation for these objects is also sound.
\end{comment}

\req{The formal model shall be executable.}
\subreq{The formal model shall be executable in debug mode (step-by-step), allowing
inspection of states, variables and I/O.}
\subreq{The environment shall be emulated by high level construction of the inputs.}

\begin{justif}
``High level'' means that it will not be necessary to define bitwise the inputs at each cycle.
On the contrary, some motorization will be available to define the behavior of the inputs.
\end{justif}

\req{It shall be possible to assert logical properties on the model (\emph{i.e. invariants}).}
\subreq{It shall be able to check the conformance of these properties at runtime.}
\subreq{It shall be able to prove the conformance of the model to these properties.}



\subsection{Use of tools}



\req{The tool chain shall be sufficiently robust to allow large software management.}
\subreq{It shall allow modularity at any level (proof, model, software).}
\subreq{It shall allow the management of documentation within the same tool.}
\subreq{It shall allow distributed software development.}
\subreq{It shall include an \emph{issue-tracking system}, in order to allow change management and 
errors/bugs management.}
\subreq{It shall allow to document/track the differences between the model and the ERTMS reference.}
\begin{justif}
In case where errors are found in the specification, or reducting choices are to be made in the 
model (\emph{e.g.} in case of non-determinism).
\end{justif}
\subreq{It shall allow concurrent version development, or be compatible with tools allowing
concurrent version development.}
\subreq{In particular, it shall be made easy\;\footnote{Especially in the case of a graphical language.}
to track the differences between two releases of a model and to manage conflicts.}
\subreq{In particular it shall allow to track the roles and responsabilities of each 
participant on a configuration item, at each step of the project lifecycle.}
\subreq{In particular, version management shall allow to track version of the safety properties 
together with the model.}

\req{The tool chain shall allow traceability between the documentation (in particular the specification) 
and the models and safety properties.}
\req{The tool chain shall allow traceability between the different layers of model and safety 
properties.}

\req{The tools used in the tool chain shall be able to cooperate, \emph{i.e.} the outputs of one 
tool will be suitable to be used as the inputs of the other tool.}

\req{The tool chain shall conform to 50128 requirements, for the corresponding SIL and tool class.}
\subreq{For T2 and T3 tools\,\footnote{T2: Tools contributing to the test or verification of the code 
or design 
\emph{e.g.} static analyzers, test generators\dots)\\ T3: tools contributing directly or indirectly
to the final code or data (\emph{e.g.} compilers, code translator\dots)}, the choice of tools shall be 
justified, and the justification shall
include how the tool's failures are covered, avoided or taken into account (ref. to EN 50128 6.7.4.2).}

\subreq{All T2 and T3 tools must be provided with their user manuals.}

\subreq{For all T3 tool, the proof of correctness  or the measure taken to guarantee the correctness 
of the output w.r.t. their specification and the inputs shall be provided.}
\subsubreq{\dots for data transformation,}
\subsubreq{\dots for software transformation (\emph{e.g.} translation, compilation\dots).}

\req{The tool chain shall allow to write and store \emph{test cases} and \emph{use cases}
for the model.}
\subreq{Version management will allow to map test cases version to model versions.}

\req{The tool chain shall allow to generate test cases for the model.}
\begin{issue}
Is it really necessary? If we have formal proofs on the models, the tests should stay at a 
functional level. Therefore generated test cases should not be interesting in this context.
\end{issue}

\begin{issue}
TBD requirements on the prover. Should it verify De Bruijn's criterion\,\footnote{\emph{I.e.}
to be able to produce a proof tree that could be verified by a simple proof checker.}.
Should at least the proof tree be exportable and checkable in another tool? (if the proof
tree itself is mandatory).
\end{issue}

